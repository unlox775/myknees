{"version":3,"file":"injected.js","mappings":";;;;;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAGA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAGA;AAGA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AArCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAwCA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAGA;;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAUA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;;AAEA;AACA;AAOA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AAQA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AAQA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAIA","sources":["webpack://ai-data-scraper-extension/./src/injected.js"],"sourcesContent":["// Injected script for advanced DOM manipulation and data extraction\n\nclass DataExtractor {\n  constructor() {\n    this.extractedData = [];\n    this.initialize();\n  }\n\n  initialize() {\n    // Listen for messages from content script\n    window.addEventListener('message', (event) => {\n      if (event.source !== window) return;\n      if (event.data.type && event.data.type.startsWith('AI_SCRAPER_')) {\n        this.handleMessage(event.data);\n      }\n    });\n\n    console.log('AI Data Scraper injected script initialized');\n  }\n\n  handleMessage(message) {\n    switch (message.type) {\n      case 'AI_SCRAPER_EXTRACT_DATA':\n        this.extractDataFromPage(message.data);\n        break;\n      case 'AI_SCRAPER_ANALYZE_PAGINATION':\n        this.analyzePagination();\n        break;\n      case 'AI_SCRAPER_NAVIGATE_PAGE':\n        this.navigateToPage(message.data);\n        break;\n      default:\n        console.warn('Unknown message type in injected script:', message.type);\n    }\n  }\n\n  async extractDataFromPage(config) {\n    try {\n      const { selectors, exclusions } = config;\n      const extractedItems = [];\n\n      // Find all matching elements\n      const elements = this.findElementsBySelectors(selectors);\n      \n      // Filter out excluded elements\n      const filteredElements = this.filterExcludedElements(elements, exclusions);\n\n      // Extract data from each element\n      for (const element of filteredElements) {\n        const itemData = this.extractElementData(element, config);\n        if (itemData) {\n          extractedItems.push(itemData);\n        }\n      }\n\n      // Send results back to content script\n      this.sendMessage({\n        type: 'AI_SCRAPER_EXTRACTION_COMPLETE',\n        data: {\n          items: extractedItems,\n          totalFound: elements.length,\n          totalExtracted: extractedItems.length,\n          timestamp: new Date().toISOString()\n        }\n      });\n\n    } catch (error) {\n      console.error('Error extracting data:', error);\n      this.sendMessage({\n        type: 'AI_SCRAPER_EXTRACTION_ERROR',\n        error: error.message\n      });\n    }\n  }\n\n  findElementsBySelectors(selectors) {\n    const elements = [];\n    \n    for (const selector of selectors) {\n      try {\n        const found = document.querySelectorAll(selector);\n        elements.push(...Array.from(found));\n      } catch (error) {\n        console.warn(`Invalid selector: ${selector}`, error);\n      }\n    }\n\n    return elements;\n  }\n\n  filterExcludedElements(elements, exclusions) {\n    if (!exclusions || exclusions.length === 0) {\n      return elements;\n    }\n\n    return elements.filter(element => {\n      for (const exclusion of exclusions) {\n        try {\n          if (element.matches(exclusion)) {\n            return false;\n          }\n        } catch (error) {\n          console.warn(`Invalid exclusion selector: ${exclusion}`, error);\n        }\n      }\n      return true;\n    });\n  }\n\n  extractElementData(element, config) {\n    const data = {};\n\n    // Extract basic text content\n    data.text = element.textContent?.trim() || '';\n    \n    // Extract attributes\n    data.attributes = this.extractAttributes(element);\n    \n    // Extract links\n    data.links = this.extractLinks(element);\n    \n    // Extract images\n    data.images = this.extractImages(element);\n    \n    // Extract structured data (JSON-LD, microdata, etc.)\n    data.structuredData = this.extractStructuredData(element);\n    \n    // Extract custom fields based on config\n    if (config.fields) {\n      for (const [fieldName, fieldConfig] of Object.entries(config.fields)) {\n        data[fieldName] = this.extractCustomField(element, fieldConfig);\n      }\n    }\n\n    // Add metadata\n    data.extractedAt = new Date().toISOString();\n    data.elementSelector = this.getElementSelector(element);\n    data.elementXPath = this.getElementXPath(element);\n\n    return data;\n  }\n\n  extractAttributes(element) {\n    const attributes = {};\n    for (let attr of element.attributes) {\n      attributes[attr.name] = attr.value;\n    }\n    return attributes;\n  }\n\n  extractLinks(element) {\n    const links = [];\n    const linkElements = element.querySelectorAll('a[href]');\n    \n    for (const link of linkElements) {\n      links.push({\n        text: link.textContent?.trim(),\n        href: link.href,\n        title: link.title\n      });\n    }\n    \n    return links;\n  }\n\n  extractImages(element) {\n    const images = [];\n    const imgElements = element.querySelectorAll('img');\n    \n    for (const img of imgElements) {\n      images.push({\n        src: img.src,\n        alt: img.alt,\n        title: img.title,\n        width: img.width,\n        height: img.height\n      });\n    }\n    \n    return images;\n  }\n\n  extractStructuredData(element) {\n    const structuredData = [];\n\n    // Extract JSON-LD\n    const jsonLdScripts = element.querySelectorAll('script[type=\"application/ld+json\"]');\n    for (const script of jsonLdScripts) {\n      try {\n        const data = JSON.parse(script.textContent);\n        structuredData.push({ type: 'json-ld', data });\n      } catch (error) {\n        console.warn('Invalid JSON-LD:', error);\n      }\n    }\n\n    // Extract microdata\n    const microdataElements = element.querySelectorAll('[itemtype]');\n    for (const item of microdataElements) {\n      const itemData = this.extractMicrodata(item);\n      if (itemData) {\n        structuredData.push({ type: 'microdata', data: itemData });\n      }\n    }\n\n    return structuredData;\n  }\n\n  extractMicrodata(element) {\n    const data = {\n      type: element.getAttribute('itemtype'),\n      properties: {}\n    };\n\n    const properties = element.querySelectorAll('[itemprop]');\n    for (const prop of properties) {\n      const propName = prop.getAttribute('itemprop');\n      let propValue = prop.textContent?.trim();\n      \n      // Handle different property types\n      if (prop.hasAttribute('content')) {\n        propValue = prop.getAttribute('content');\n      } else if (prop.hasAttribute('src')) {\n        propValue = prop.getAttribute('src');\n      } else if (prop.hasAttribute('href')) {\n        propValue = prop.getAttribute('href');\n      }\n\n      if (propValue) {\n        data.properties[propName] = propValue;\n      }\n    }\n\n    return data;\n  }\n\n  extractCustomField(element, fieldConfig) {\n    const { selector, attribute, type } = fieldConfig;\n    \n    try {\n      let targetElement = element;\n      \n      if (selector) {\n        targetElement = element.querySelector(selector);\n        if (!targetElement) return null;\n      }\n\n      switch (type) {\n        case 'text':\n          return targetElement.textContent?.trim();\n        case 'attribute':\n          return targetElement.getAttribute(attribute);\n        case 'html':\n          return targetElement.innerHTML;\n        case 'number':\n          const text = targetElement.textContent?.trim();\n          return text ? parseFloat(text.replace(/[^\\d.-]/g, '')) : null;\n        case 'date':\n          const dateText = targetElement.textContent?.trim();\n          return dateText ? new Date(dateText).toISOString() : null;\n        default:\n          return targetElement.textContent?.trim();\n      }\n    } catch (error) {\n      console.warn('Error extracting custom field:', error);\n      return null;\n    }\n  }\n\n  getElementSelector(element) {\n    if (element.id) {\n      return `#${element.id}`;\n    }\n\n    if (element.className) {\n      const classes = element.className.split(' ').filter(c => c.trim());\n      if (classes.length > 0) {\n        return `.${classes.join('.')}`;\n      }\n    }\n\n    return element.tagName.toLowerCase();\n  }\n\n  getElementXPath(element) {\n    if (element.id) {\n      return `//*[@id=\"${element.id}\"]`;\n    }\n\n    let path = '';\n    while (element && element.nodeType === Node.ELEMENT_NODE) {\n      let index = 1;\n      let sibling = element.previousSibling;\n      while (sibling) {\n        if (sibling.nodeType === Node.ELEMENT_NODE && sibling.tagName === element.tagName) {\n          index++;\n        }\n        sibling = sibling.previousSibling;\n      }\n\n      const tagName = element.tagName.toLowerCase();\n      const pathIndex = index > 1 ? `[${index}]` : '';\n      path = `/${tagName}${pathIndex}${path}`;\n      element = element.parentNode;\n    }\n\n    return path;\n  }\n\n  analyzePagination() {\n    const paginationData = {\n      hasPagination: false,\n      currentPage: null,\n      totalPages: null,\n      nextPageUrl: null,\n      prevPageUrl: null,\n      paginationElements: []\n    };\n\n    // Look for common pagination patterns\n    const paginationSelectors = [\n      '.pagination',\n      '.pager',\n      '.page-numbers',\n      '[class*=\"pagination\"]',\n      '[class*=\"pager\"]',\n      'nav[aria-label*=\"pagination\"]',\n      'nav[aria-label*=\"pager\"]'\n    ];\n\n    for (const selector of paginationSelectors) {\n      const elements = document.querySelectorAll(selector);\n      if (elements.length > 0) {\n        paginationData.hasPagination = true;\n        paginationData.paginationElements.push(...Array.from(elements));\n        break;\n      }\n    }\n\n    // Analyze pagination structure\n    if (paginationData.hasPagination) {\n      this.analyzePaginationStructure(paginationData);\n    }\n\n    this.sendMessage({\n      type: 'AI_SCRAPER_PAGINATION_ANALYSIS',\n      data: paginationData\n    });\n  }\n\n  analyzePaginationStructure(paginationData) {\n    const paginationElement = paginationData.paginationElements[0];\n    \n    // Find current page\n    const currentPageSelectors = [\n      '.current',\n      '.active',\n      '[aria-current=\"page\"]',\n      '.page-numbers.current'\n    ];\n\n    for (const selector of currentPageSelectors) {\n      const current = paginationElement.querySelector(selector);\n      if (current) {\n        const pageText = current.textContent?.trim();\n        paginationData.currentPage = parseInt(pageText) || 1;\n        break;\n      }\n    }\n\n    // Find next/previous links\n    const nextLink = paginationElement.querySelector('a[rel=\"next\"], .next, .next-page');\n    if (nextLink) {\n      paginationData.nextPageUrl = nextLink.href;\n    }\n\n    const prevLink = paginationElement.querySelector('a[rel=\"prev\"], .prev, .prev-page');\n    if (prevLink) {\n      paginationData.prevPageUrl = prevLink.href;\n    }\n\n    // Estimate total pages\n    const pageNumbers = paginationElement.querySelectorAll('a, .page-numbers');\n    if (pageNumbers.length > 0) {\n      const numbers = Array.from(pageNumbers)\n        .map(el => parseInt(el.textContent?.trim()))\n        .filter(num => !isNaN(num));\n      \n      if (numbers.length > 0) {\n        paginationData.totalPages = Math.max(...numbers);\n      }\n    }\n  }\n\n  navigateToPage(navigationData) {\n    const { action, url } = navigationData;\n    \n    try {\n      switch (action) {\n        case 'next':\n          if (url) {\n            window.location.href = url;\n          } else {\n            this.clickNextPage();\n          }\n          break;\n        case 'prev':\n          if (url) {\n            window.location.href = url;\n          } else {\n            this.clickPrevPage();\n          }\n          break;\n        case 'specific':\n          if (url) {\n            window.location.href = url;\n          }\n          break;\n        default:\n          console.warn('Unknown navigation action:', action);\n      }\n    } catch (error) {\n      console.error('Error navigating to page:', error);\n      this.sendMessage({\n        type: 'AI_SCRAPER_NAVIGATION_ERROR',\n        error: error.message\n      });\n    }\n  }\n\n  clickNextPage() {\n    const nextSelectors = [\n      'a[rel=\"next\"]',\n      '.next',\n      '.next-page',\n      '.pagination .next',\n      '.pager .next'\n    ];\n\n    for (const selector of nextSelectors) {\n      const nextButton = document.querySelector(selector);\n      if (nextButton) {\n        nextButton.click();\n        return;\n      }\n    }\n  }\n\n  clickPrevPage() {\n    const prevSelectors = [\n      'a[rel=\"prev\"]',\n      '.prev',\n      '.prev-page',\n      '.pagination .prev',\n      '.pager .prev'\n    ];\n\n    for (const selector of prevSelectors) {\n      const prevButton = document.querySelector(selector);\n      if (prevButton) {\n        prevButton.click();\n        return;\n      }\n    }\n  }\n\n  sendMessage(message) {\n    window.postMessage(message, '*');\n  }\n}\n\n// Initialize data extractor\nnew DataExtractor();"],"names":[],"sourceRoot":""}